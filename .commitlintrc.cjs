/** @type {import('@commitlint/types').UserConfig} */
module.exports = {
  // Conventional Commits baseline (works with semantic-release)
  extends: ['@commitlint/config-conventional'],

  // Optional: skip merges
  ignores: [(msg) => /^Merge\b/i.test(msg)],

  // Inline plugin adds custom rules for privacy and attribution
  plugins: [
    {
      rules: {
        'no-emails-anywhere': (parsed, when = 'always') => {
          // Aggregate all text we care about
          const { header = '', body = '', footer = '' } = parsed;
          const text = [header, body, footer].filter(Boolean).join('\n');

          // Simple, pragmatic RFC 5322-ish email detector
          const EMAIL = /\b[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,}\b/i;

          // Evaluate
          const hasEmail = EMAIL.test(text);
          const pass = when === 'never' ? hasEmail : !hasEmail;

          return [
            pass,
            'No email addresses in commits (privacy & single authorship).\n' +
            'Git already records your email in commit metadata.\n' +
            'Use @username or issue #123 for references.',
          ];
        },
        'no-ai-attribution-trailers': (parsed, when = 'always') => {
          const { body = '', footer = '' } = parsed;
          const text = [body, footer].filter(Boolean).join('\n');
          
          // Check for AI attribution patterns
          const AI_TRAILER = /^\s*(Co-Authored-By|Co-authored-by):/im;
          const hasAITrailer = AI_TRAILER.test(text);
          const pass = when === 'never' ? hasAITrailer : !hasAITrailer;
          
          return [
            pass,
            'No "Co-Authored-By" trailers (single authorship principle).\n' +
            'Each commit has ONE author who takes full responsibility.\n' +
            'Collaboration happens in PRs/issues, not commit messages.',
          ];
        },
        'body-required-with-guidance': (parsed, when = 'always') => {
          const { body } = parsed;
          const hasBody = body && body.trim().length > 0;
          const pass = when === 'never' ? hasBody : !hasBody;
          
          if (pass) return [true];
          
          return [
            false,
            'Body is required - explain what changed and why.\n' +
            'Format: <header>\\n<blank line>\\n<body>\n' +
            'Example:\n' +
            '  feat: add user authentication\n' +
            '  \n' +
            '  Implemented OAuth2 for secure user login.'
          ];
        },
        'type-required-with-guidance': (parsed, when = 'always') => {
          const { type } = parsed;
          const hasType = type && type.trim().length > 0;
          const pass = when === 'always' ? hasType : !hasType;
          
          if (pass) return [true];
          
          return [
            false,
            'Type prefix required. Valid types:\n' +
            '  feat (new feature), fix (bug fix), perf (performance),\n' +
            '  refactor, docs, chore, test, build, ci, style, revert\n' +
            'Example: "feat: add login" or "fix: resolve crash"'
          ];
        },
        'no-external-attribution': (parsed, when = 'always') => {
          const { header = '', body = '', footer = '' } = parsed;
          const fullText = [header, body, footer].filter(Boolean).join('\n');
          
          // Patterns that suggest shared/external authorship
          const ATTRIBUTION_PATTERNS = /Co-Authored-By|Co-authored-by|Generated with|generated by|Assisted by|Thanks to|With help from|ðŸ‘¥|ðŸ¤–|Created by|Authored by|Written by|Produced by|Made with|Attribution:|Credits:|Acknowledgment:/i;
          
          // Specific tool/entity mentions that suggest attribution
          const ENTITY_PATTERNS = /\b(Claude|Anthropic|ChatGPT|OpenAI|Copilot|Gemini|Bard|AI|LLM|bot|assistant)\b.*(?:generated|created|wrote|helped|assisted)/i;
          
          const hasAttribution = ATTRIBUTION_PATTERNS.test(fullText) || ENTITY_PATTERNS.test(fullText);
          
          return [
            !hasAttribution,
            'Commits must have single authorship - no external attribution.\n' +
            'Remove ALL attribution (Co-Authored-By, Generated with, Thanks to, etc.).\n' +
            'Git already tracks authorship. Additional attribution dilutes responsibility.\n' +
            'One commit = one author = clear ownership.'
          ];
        },
      },
    },
  ],

  rules: {
    /* length budgets */
    'header-max-length': [2, 'always', 100],
    'body-max-line-length': [2, 'always', 100],
    'footer-max-line-length': [2, 'always', 100],

    /* require a body + proper separator */
    'body-empty': [2, 'never'],            // a body is required
    'body-leading-blank': [2, 'always'],   // blank line after header

    /* subject hygiene */
    'subject-empty': [2, 'never'],
    'subject-full-stop': [2, 'never', '.'],

    /* type hygiene (keeps semantic-release happy) */
    'type-empty': [2, 'never'],
    'type-case': [2, 'always', 'lower-case'],
    // Tighten the allowed types if you want; these align with config-conventional
    'type-enum': [
      2,
      'always',
      [
        'feat', 'fix', 'perf', 'refactor', 'docs',
        'chore', 'test', 'build', 'ci', 'style', 'revert',
      ],
    ],

    /* custom: enforce single authorship principle */
    'no-emails-anywhere': [2, 'always'],
    'no-ai-attribution-trailers': [2, 'always'],
    'no-external-attribution': [2, 'always'],
    'body-required-with-guidance': [2, 'never'],
    'type-required-with-guidance': [2, 'always'],
  },
};