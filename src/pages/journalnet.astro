---
import BaseLayout from "../layouts/BaseLayout.astro";
---

<BaseLayout
  title="JournalNet â€” Journal Foundation"
  description="A network where privacy is default. Apps don't own your data."
>
  <main class="journalnet-page">
    
    <section class="hero">
      <div class="container">
        <h1>JournalNet</h1>
        <p class="definition">
          A network where apps request access to data they don't host.
        </p>
      </div>
    </section>

    <section class="network-viz">
      <div class="container">
        <div id="graph-container"></div>
        <div class="graph-legend">
          <span class="legend-item">
            <span class="dot vault"></span> Vaults (user-controlled storage)
          </span>
          <span class="legend-item">
            <span class="dot app"></span> Apps (request capabilities)
          </span>
          <span class="legend-item">
            <span class="dot relay"></span> Blind relays (metadata protection)
          </span>
        </div>
      </div>
    </section>

    <section class="explainer">
      <div class="container">
        <div class="explainer-grid">
          <div>
            <h2>Vaults</h2>
            <p>Encrypted storage. You control it.</p>
          </div>
          <div>
            <h2>Capabilities</h2>
            <p>Temporary, scoped, revocable access tokens.</p>
          </div>
          <div>
            <h2>Apps</h2>
            <p>Swappable interfaces. Data stays in your vault.</p>
          </div>
        </div>
      </div>
    </section>

    <section class="principles">
      <div class="container">
        <h2>Three Principles</h2>
        <ol>
          <li>Apps don't custody your data</li>
          <li>Metadata is minimized by default</li>
          <li>Access is capability-based, not credential-based</li>
        </ol>
      </div>
    </section>

    <section class="cta">
      <div class="container">
        <h2>Build on JournalNet</h2>
        <div class="cta-actions">
          <a href="/stack" class="btn btn--primary">See the protocol stack</a>
          <a href="/docs" class="btn btn--secondary">Start building</a>
        </div>
      </div>
    </section>

  </main>
</BaseLayout>

<script>
  import ForceGraph from 'force-graph';

  const container = document.getElementById('graph-container');
  if (container) {

    const layerConfig = {
      app: { order: 0, color: '#2d7dff' },
      relay: { order: 1, color: '#f5b400' },
      vault: { order: 2, color: '#0dd280' }
    };

    // Generate network data
    const numVaults = 8;
    const numApps = 5;
    const numRelays = 3;

    const vaults = Array.from({length: numVaults}, (_, i) => ({
      id: `vault-${i}`,
      type: 'vault',
      label: `Vault ${i + 1}`
    }));

    const apps = Array.from({length: numApps}, (_, i) => ({
      id: `app-${i}`,
      type: 'app',
      label: `App ${i + 1}`
    }));

    const relays = Array.from({length: numRelays}, (_, i) => ({
      id: `relay-${i}`,
      type: 'relay',
      label: `Relay ${i + 1}`
    }));

    const nodes = [...apps, ...relays, ...vaults];

    // Create connections: apps -> relays -> vaults
    const links = [];

    apps.forEach(app => {
      const connectedRelays = relays
        .map(relay => ({ relay, weight: Math.random() }))
        .sort((a, b) => a.weight - b.weight)
        .slice(0, 2)
        .map(entry => entry.relay);

      connectedRelays.forEach(relay => {
        links.push({
          source: app.id,
          target: relay.id
        });
      });
    });

    relays.forEach(relay => {
      const connectedVaults = vaults
        .map(vault => ({ vault, weight: Math.random() }))
        .sort((a, b) => a.weight - b.weight)
        .slice(0, 4)
        .map(entry => entry.vault);

      connectedVaults.forEach(vault => {
        links.push({
          source: relay.id,
          target: vault.id
        });
      });
    });

    const layerSpacing = 160;
    const horizontalSpacing = 130;

    const typeMeta = nodes.reduce((acc, node) => {
      const meta = acc[node.type] ?? { count: 0 };
      meta.count += 1;
      acc[node.type] = meta;
      return acc;
    }, {});

    Object.keys(typeMeta).forEach(type => {
      const meta = typeMeta[type];
      meta.midpoint = (meta.count - 1) / 2;
      meta.index = 0;
    });

    const positionedNodes = nodes.map(node => {
      const meta = typeMeta[node.type];
      const offsetIndex = meta.index++;

      const fx = (offsetIndex - meta.midpoint) * horizontalSpacing;
      const fy = (layerConfig[node.type].order - 1) * layerSpacing;

      return {
        ...node,
        fx,
        fy,
        x: fx,
        y: fy
      };
    });

    const data = { nodes: positionedNodes, links };

    const Graph = ForceGraph()(container)
      .graphData(data)
      .nodeLabel('label')
      .nodeRelSize(6)
      .backgroundColor('#05070a')
      .linkColor(() => 'rgba(255, 255, 255, 0.2)')
      .linkWidth(1.5)
      .linkDirectionalArrowLength(3)
      .linkDirectionalArrowRelPos(0.98)
      .linkDirectionalParticles(4)
      .linkDirectionalParticleWidth(() => 4)
      .linkDirectionalParticleSpeed(() => 0.004)
      .width(container.clientWidth)
      .height(500);

    const getNodeColor = node => layerConfig[node.type]?.color ?? '#666';

    Graph.linkDirectionalParticleColor(link => {
      const sourceNode = typeof link.source === 'object'
        ? link.source
        : positionedNodes.find(node => node.id === link.source);
      return getNodeColor(sourceNode ?? {});
    });

    Graph.nodeCanvasObject((node, ctx, globalScale) => {
      const baseSize = 10;
      const pulse = (Date.now() % 2000) / 2000;
      const radius = baseSize / Math.sqrt(globalScale);
      const glowRadius = radius + (Math.sin(pulse * Math.PI * 2) + 1) * 4;

      ctx.save();
      ctx.globalCompositeOperation = 'lighter';

      const gradient = ctx.createRadialGradient(node.x, node.y, radius * 0.4, node.x, node.y, glowRadius);
      const color = getNodeColor(node);
      gradient.addColorStop(0, color);
      gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');

      ctx.fillStyle = gradient;
      ctx.beginPath();
      ctx.arc(node.x, node.y, glowRadius, 0, 2 * Math.PI, false);
      ctx.fill();

      ctx.globalCompositeOperation = 'source-over';
      ctx.fillStyle = color;
      ctx.beginPath();
      ctx.arc(node.x, node.y, radius, 0, 2 * Math.PI, false);
      ctx.fill();
      ctx.restore();
    });

    Graph.nodePointerAreaPaint((node, color, ctx) => {
      ctx.fillStyle = color;
      ctx.beginPath();
      ctx.arc(node.x, node.y, 14, 0, 2 * Math.PI, false);
      ctx.fill();
    });

    Graph.onEngineStop(() => {
      Graph.zoomToFit(400, 90);
    });
  }
</script>

<style>
  .journalnet-page {
    padding-bottom: var(--space-3xl);
  }

  .hero {
    padding: var(--space-3xl) 0 var(--space-2xl);
    text-align: center;
  }

  .hero h1 {
    margin-bottom: var(--space-md);
  }

  .definition {
    font-size: var(--step-1);
    color: var(--color-text-secondary);
    max-width: 60ch;
    margin: 0 auto;
  }

  .network-viz {
    padding: var(--space-2xl) 0;
    background: rgba(17, 24, 33, 0.35);
  }

  #graph-container {
    position: relative;
    width: 100%;
    height: 500px;
    border-radius: var(--radius-lg);
    overflow: hidden;
    background: var(--color-surface-void);
    border: 1px solid var(--color-border-subtle);
  }

  #graph-container::after {
    content: "";
    position: absolute;
    inset: 0;
    background: linear-gradient(
        to bottom,
        rgba(45, 125, 255, 0.08) 0%,
        rgba(45, 125, 255, 0.08) 33%,
        rgba(245, 180, 0, 0.08) 33%,
        rgba(245, 180, 0, 0.08) 66%,
        rgba(13, 210, 128, 0.08) 66%,
        rgba(13, 210, 128, 0.08) 100%
      );
    mix-blend-mode: screen;
    opacity: 0.4;
    pointer-events: none;
  }

  .graph-legend {
    display: flex;
    gap: var(--space-lg);
    justify-content: center;
    margin-top: var(--space-md);
    flex-wrap: wrap;
  }

  .legend-item {
    display: flex;
    align-items: center;
    gap: var(--space-2xs);
    color: var(--color-text-secondary);
    font-size: var(--step--1);
  }

  .dot {
    width: 12px;
    height: 12px;
    border-radius: 50%;
  }

  .dot.vault {
    background: #0dd280;
  }

  .dot.app {
    background: #2d7dff;
  }

  .dot.relay {
    background: #f5b400;
  }

  .explainer {
    padding: var(--space-3xl) 0;
  }

  .explainer-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: var(--space-xl);
    text-align: center;
  }

  .explainer-grid h2 {
    margin-bottom: var(--space-xs);
    font-size: var(--step-1);
  }

  .explainer-grid p {
    color: var(--color-text-secondary);
    margin: 0;
  }

  .principles {
    padding: var(--space-3xl) 0;
    background: rgba(17, 24, 33, 0.35);
  }

  .principles h2 {
    text-align: center;
    margin-bottom: var(--space-xl);
  }

  .principles ol {
    max-width: 60ch;
    margin: 0 auto;
    font-size: var(--step-0);
    line-height: 2;
    color: var(--color-text-secondary);
  }

  .cta {
    padding: var(--space-3xl) 0;
    text-align: center;
  }

  .cta h2 {
    margin-bottom: var(--space-lg);
  }

  .cta-actions {
    display: flex;
    gap: var(--space-sm);
    justify-content: center;
    flex-wrap: wrap;
  }

  .cta-actions .btn {
    min-width: 200px;
  }
</style>